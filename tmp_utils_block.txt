                std::ostringstream gpu_text;
                gpu_text << "GPU: " << gpu_usage << "% @" << gpu_freq << "MHz";
                lv_label_set_text(widgets.gpu_label, gpu_text.str().c_str());
                
                lv_obj_set_style_bg_color(widgets.gpu_bar, colors.warning, LV_PART_INDICATOR);
            }
        }
        
        // === æ›´æ–°å†…å­˜ä¿¡æ¯ ===
        if (widgets.mem_bar && widgets.mem_label) {
            if (stats.memory.ram_total_mb > 0 && stats.memory.ram_used_mb >= 0 &&
                stats.memory.ram_used_mb <= stats.memory.ram_total_mb) {
                
                int mem_percentage = (stats.memory.ram_used_mb * 100) / stats.memory.ram_total_mb;
                mem_percentage = std::max(0, std::min(100, mem_percentage));
                
                lv_bar_set_value(widgets.mem_bar, mem_percentage, LV_ANIM_ON);
                
                std::ostringstream mem_text;
                mem_text << "RAM: " << stats.memory.ram_used_mb << "/" 
                         << stats.memory.ram_total_mb << "MB";
                lv_label_set_text(widgets.mem_label, mem_text.str().c_str());
                
                lv_obj_set_style_bg_color(widgets.mem_bar, colors.warning, LV_PART_INDICATOR);
            }
        }
        
        // === æ›´æ–°æ¸©åº¦ä¿¡æ¯ ===
        if (widgets.cpu_temp_label) {
            std::ostringstream temp_text;
            temp_text << "Temp: CPU " << stats.temperature.cpu_temp << "Â°C "
                      << "GPU " << stats.temperature.gpu_temp << "Â°C";
            lv_label_set_text(widgets.cpu_temp_label, temp_text.str().c_str());
        }
        
        // === æ›´æ–° SWAP ä½¿ç”¨æƒ…å†µ ===
        if (widgets.swap_usage_label) {
            std::ostringstream swap_text;
            swap_text << "SWAP: " << stats.memory.swap_used_mb << "/" 
                      << stats.memory.swap_total_mb << "MB";
            lv_label_set_text(widgets.swap_usage_label, swap_text.str().c_str());
        }
        
        return true;
        
    } catch (const std::exception& e) {
        std::cerr << "[lvgl_ui_utils] Exception in updateJetsonMonitoring: " << e.what() << std::endl;
        return false;
    }
}

// ==================== AI æ¨¡å‹ç»Ÿè®¡æ›´æ–° ====================

bool updateAIModelStats(
    LVGLControlWidgets& widgets,
    std::shared_ptr<bamboo_cut::core::DataBridge> data_bridge) {
    
    if (!data_bridge) {
        return false;
    }
    
    try {
        // è·å– AI æ¨¡å‹ç»Ÿè®¡æ•°æ®
        // æ³¨æ„ï¼šè¿™äº›æ–¹æ³•éœ€è¦åœ¨ DataBridge ä¸­å®ç?
        
        // === æ›´æ–° FPS ===
        if (widgets.ai_fps_label) {
            // TODO: ä»?DataBridge è·å–å®é™… FPS
            static int simulated_fps = 0;
            simulated_fps = (simulated_fps + 1) % 60 + 20;  // æ¨¡æ‹Ÿ 20-80 fps
            
            std::ostringstream fps_text;
            fps_text << "FPS: " << simulated_fps << " fps";
            lv_label_set_text(widgets.ai_fps_label, fps_text.str().c_str());
        }
        
        // === æ›´æ–°æ£€æµ‹æ•°é‡?===
        if (widgets.ai_total_detections_label) {
            // TODO: ä»?DataBridge è·å–å®é™…æ£€æµ‹æ•°é‡?
            static int detection_count = 0;
            detection_count++;
            
            std::ostringstream detect_text;
            detect_text << "Detected: " << detection_count << " objects";
            lv_label_set_text(widgets.ai_total_detections_label, detect_text.str().c_str());
        }
        
        // === æ›´æ–°æ¨ç†æ—¶é—´ ===
        if (widgets.ai_inference_time_label) {
            // TODO: ä»?DataBridge è·å–å®é™…æ¨ç†æ—¶é—´
            static int inference_ms = 0;
            inference_ms = (inference_ms + 1) % 30 + 10;  // æ¨¡æ‹Ÿ 10-40ms
            
            std::ostringstream time_text;
            time_text << "Inference: " << inference_ms << "ms";
            lv_label_set_text(widgets.ai_inference_time_label, time_text.str().c_str());
        }
        
        return true;
        
    } catch (const std::exception& e) {
        std::cerr << "[lvgl_ui_utils] Exception in updateAIModelStats: " << e.what() << std::endl;
        return false;
    }
}

// ==================== æ‘„åƒå¤´çŠ¶æ€æ›´æ–?====================

bool updateCameraStatus(
    LVGLControlWidgets& widgets,
    std::shared_ptr<bamboo_cut::core::DataBridge> data_bridge) {
    
    if (!data_bridge) {
        return false;
    }
    
    try {
        // === æ›´æ–°æ‘„åƒå¤´çŠ¶æ€?===
        if (widgets.camera_status_label) {
            lv_label_set_text(widgets.camera_status_label, "Camera: Online");
