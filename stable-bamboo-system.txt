// 竹子切割系统 - 稳定重构方案
// 解决日志中发现的核心问题：优雅关闭失败、通信协议错误、进程管理混乱

#include <opencv2/opencv.hpp>
#include <atomic>
#include <thread>
#include <mutex>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <chrono>

// 1. 全局优雅退出管理
class GracefulShutdown {
private:
    static std::atomic<bool> shutdown_requested;
    static std::chrono::steady_clock::time_point shutdown_start_time;
    
public:
    static void signal_handler(int signum) {
        std::cout << "收到信号 " << signum << "，开始5秒内优雅退出..." << std::endl;
        shutdown_requested = true;
        shutdown_start_time = std::chrono::steady_clock::now();
    }
    
    static bool should_shutdown() { 
        return shutdown_requested; 
    }
    
    static bool force_exit() {
        if (!shutdown_requested) return false;
        auto elapsed = std::chrono::steady_clock::now() - shutdown_start_time;
        return elapsed > std::chrono::seconds(4); // 4秒后强制退出
    }
    
    static void setup() {
        signal(SIGTERM, signal_handler);
        signal(SIGINT, signal_handler);
        signal(SIGPIPE, SIG_IGN);
    }
};

std::atomic<bool> GracefulShutdown::shutdown_requested{false};
std::chrono::steady_clock::time_point GracefulShutdown::shutdown_start_time;

// 2. 修复的消息协议
#define MSG_MAGIC 0xBABECAFE
enum class MessageType : uint32_t {
    HEARTBEAT = 1001,
    START_CUTTING = 1002,
    STOP_CUTTING = 1003,
    STATUS_REQUEST = 1004,
    PARAMETER_UPDATE = 1005
};

struct MessageHeader {
    uint32_t magic = MSG_MAGIC;
    uint32_t type;
    uint32_t length;
    uint32_t checksum;
};

class ReliableComm {
private:
    int server_socket = -1;
    int client_socket = -1;
    std::thread comm_thread;
    std::atomic<bool> comm_running{false};
    
    uint32_t calculate_checksum(const void* data, size_t len) {
        // 简单校验和
        const uint8_t* bytes = static_cast<const uint8_t*>(data);
        uint32_t sum = 0;
        for (size_t i = 0; i < len; i++) {
            sum += bytes[i];
        }
        return sum;
    }
    
public:
    bool start_server(int port = 8888) {
        server_socket = socket(AF_INET, SOCK_STREAM, 0);
        if (server_socket < 0) return false;
        
        // 允许端口重用
        int opt = 1;
        setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
        
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = INADDR_ANY;
        addr.sin_port = htons(port);
        
        if (bind(server_socket, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
            close(server_socket);
            return false;
        }
        
        if (listen(server_socket, 1) < 0) {
            close(server_socket);
            return false;
        }
        
        comm_running = true;
        comm_thread = std::thread(&ReliableComm::server_loop, this);
        return true;
    }
    
    bool send_message(MessageType type, const void* data = nullptr, size_t len = 0) {
        if (client_socket < 0) return false;
        
        MessageHeader header;
        header.type = static_cast<uint32_t>(type);
        header.length = len;
        header.checksum = len > 0 ? calculate_checksum(data, len) : 0;
        
        // 发送头部
        if (send(client_socket, &header, sizeof(header), MSG_NOSIGNAL) != sizeof(header)) {
            return false;
        }
        
        // 发送数据
        if (len > 0) {
            if (send(client_socket, data, len, MSG_NOSIGNAL) != static_cast<ssize_t>(len)) {
                return false;
            }
        }
        
        return true;
    }
    
    bool receive_message(MessageType& type, std::vector<uint8_t>& data) {
        if (client_socket < 0) return false;
        
        MessageHeader header;
        ssize_t received = recv(client_socket, &header, sizeof(header), MSG_WAITALL);
        if (received != sizeof(header)) return false;
        
        // 验证魔数
        if (header.magic != MSG_MAGIC) {
            std::cerr << "无效消息魔数: " << std::hex << header.magic << std::endl;
            return false;
        }
        
        // 验证消息类型
        if (header.type < 1001 || header.type > 1005) {
            std::cerr << "无效消息类型: " << header.type << std::endl;
            return false;
        }
        
        type = static_cast<MessageType>(header.type);
        
        // 接收数据
        if (header.length > 0) {
            data.resize(header.length);
            received = recv(client_socket, data.data(), header.length, MSG_WAITALL);
            if (received != static_cast<ssize_t>(header.length)) return false;
            
            // 验证校验和
            if (calculate_checksum(data.data(), header.length) != header.checksum) {
                std::cerr << "数据校验失败" << std::endl;
                return false;
            }
        } else {
            data.clear();
        }
        
        return true;
    }
    
    void stop() {
        comm_running = false;
        if (client_socket >= 0) {
            close(client_socket);
            client_socket = -1;
        }
        if (server_socket >= 0) {
            close(server_socket);
            server_socket = -1;
        }
        if (comm_thread.joinable()) {
            comm_thread.join();
        }
    }
    
private:
    void server_loop() {
        while (comm_running && !GracefulShutdown::should_shutdown()) {
            fd_set readfds;
            FD_ZERO(&readfds);
            FD_SET(server_socket, &readfds);
            
            struct timeval timeout = {1, 0}; // 1秒超时
            int activity = select(server_socket + 1, &readfds, NULL, NULL, &timeout);
            
            if (activity > 0 && FD_ISSET(server_socket, &readfds)) {
                client_socket = accept(server_socket, NULL, NULL);
                if (client_socket >= 0) {
                    std::cout << "前端连接成功" << std::endl;
                    handle_client();
                }
            }
        }
    }
    
    void handle_client() {
        while (comm_running && !GracefulShutdown::should_shutdown() && client_socket >= 0) {
            MessageType type;
            std::vector<uint8_t> data;
            
            if (receive_message(type, data)) {
                process_message(type, data);
            } else {
                // 连接断开或错误
                break;
            }
        }
        
        if (client_socket >= 0) {
            close(client_socket);
            client_socket = -1;
        }
    }
    
    void process_message(MessageType type, const std::vector<uint8_t>& data) {
        switch (type) {
            case MessageType::HEARTBEAT:
                std::cout << "收到心跳" << std::endl;
                break;
            case MessageType::START_CUTTING:
                std::cout << "开始切割" << std::endl;
                break;
            case MessageType::STOP_CUTTING:
                std::cout << "停止切割" << std::endl;
                break;
            case MessageType::STATUS_REQUEST:
                std::cout << "状态请求" << std::endl;
                break;
            case MessageType::PARAMETER_UPDATE:
                std::cout << "参数更新" << std::endl;
                break;
        }
    }
};

// 3. 简化的单线程视频系统
class SimpleVideoSystem {
private:
    cv::VideoCapture camera;
    cv::VideoWriter stream_writer;
    bool video_initialized = false;
    int frame_count = 0;
    
public:
    bool initialize() {
        // 尝试多种摄像头初始化方式
        if (camera.open("/dev/video0")) {
            std::cout << "使用 /dev/video0" << std::endl;
        } else if (camera.open(0)) {
            std::cout << "使用默认摄像头" << std::endl;
        } else {
            std::cerr << "摄像头初始化失败" << std::endl;
            return false;
        }
        
        // 设置摄像头参数
        camera.set(cv::CAP_PROP_FRAME_WIDTH, 640);
        camera.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
        camera.set(cv::CAP_PROP_FPS, 30);
        camera.set(cv::CAP_PROP_BUFFERSIZE, 1); // 减少缓冲延迟
        
        video_initialized = true;
        return true;
    }
    
    void run() {
        if (!video_initialized) return;
        
        cv::Mat frame;
        auto last_frame_time = std::chrono::steady_clock::now();
        
        while (!GracefulShutdown::should_shutdown()) {
            // 读取帧
            if (!camera.read(frame)) {
                std::cerr << "读取帧失败" << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                continue;
            }
            
            frame_count++;
            
            // 处理帧 - 替代复杂的stereo-source处理
            process_frame(frame);
            
            // 控制帧率到30fps
            auto now = std::chrono::steady_clock::now();
            auto frame_duration = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_frame_time);
            if (frame_duration < std::chrono::milliseconds(33)) {
                std::this_thread::sleep_for(std::chrono::milliseconds(33) - frame_duration);
            }
            last_frame_time = std::chrono::steady_clock::now();
            
            // 快速退出检查
            if (GracefulShutdown::force_exit()) break;
        }
        
        std::cout << "视频系统正常退出，处理了 " << frame_count << " 帧" << std::endl;
    }
    
private:
    void process_frame(const cv::Mat& frame) {
        // 简单处理，避免复杂操作
        // 这里可以添加你需要的图像处理逻辑
        
        // 每100帧输出一次状态（而不是每帧都显示计数）
        if (frame_count % 100 == 0) {
            std::cout << "已处理 " << frame_count << " 帧" << std::endl;
        }
        
        // 如果需要显示（调试时使用，生产环境可注释掉）
        #ifdef DEBUG_DISPLAY
        cv::imshow("Video", frame);
        cv::waitKey(1);
        #endif
    }
};

// 4. 主应用程序类
class BambooSystem {
private:
    SimpleVideoSystem video_system;
    ReliableComm comm_system;
    std::thread video_thread;
    
public:
    bool initialize() {
        std::cout << "初始化竹子切割系统..." << std::endl;
        
        // 设置信号处理
        GracefulShutdown::setup();
        
        // 初始化视频系统
        if (!video_system.initialize()) {
            std::cerr << "视频系统初始化失败" << std::endl;
            return false;
        }
        
        // 初始化通信系统
        if (!comm_system.start_server()) {
            std::cerr << "通信系统初始化失败" << std::endl;
            return false;
        }
        
        std::cout << "系统初始化完成" << std::endl;
        return true;
    }
    
    void run() {
        // 启动视频处理线程
        video_thread = std::thread(&SimpleVideoSystem::run, &video_system);
        
        // 主线程处理其他任务或等待
        while (!GracefulShutdown::should_shutdown()) {
            // 可以在这里添加其他系统任务
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
        
        std::cout << "开始系统关闭流程..." << std::endl;
        cleanup();
    }
    
private:
    void cleanup() {
        // 按顺序清理资源
        std::cout << "1. 停止通信系统..." << std::endl;
        comm_system.stop();
        
        std::cout << "2. 等待视频线程退出..." << std::endl;
        if (video_thread.joinable()) {
            video_thread.join();
        }
        
        std::cout << "系统清理完成" << std::endl;
    }
};

// 5. 主函数
int main() {
    std::cout << "启动竹子切割系统后端..." << std::endl;
    
    BambooSystem system;
    
    if (!system.initialize()) {
        std::cerr << "系统初始化失败" << std::endl;
        return -1;
    }
    
    system.run();
    
    std::cout << "系统正常退出" << std::endl;
    return 0;
}

// 编译命令:
// g++ -std=c++17 -O2 bamboo_system.cpp -o bamboo_system `pkg-config --cflags --libs opencv4` -pthread

// systemd服务配置 (bamboo-backend.service):
/*
[Unit]
Description=Bamboo Cutting System Backend
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/home/lip/bamboo-develop
ExecStart=/home/lip/bamboo-develop/bamboo_system
Restart=always
RestartSec=5
TimeoutStopSec=10
KillMode=mixed
KillSignal=SIGTERM

[Install]
WantedBy=multi-user.target
*/