# 智能切竹机PLC数据传输规范

## 数据传输优化策略

### 设计目标
1. **减少通信压力** - 通过分层数据传输和变化检测
2. **提高实时性** - 关键状态数据优先传输
3. **确保可靠性** - 重要数据冗余和校验机制
4. **降低带宽消耗** - 数据压缩和批量传输

---

## PLC数据结构定义

### 1. 核心状态数据 (32字节) - 高频传输 (50ms)

```
字节偏移  |  数据名称        |  数据类型  |  单位  |  说明
---------|-----------------|----------|--------|------------------
0-7      |  时间戳          |  UInt64  |  ns    |  系统时间戳
8-11     |  设备状态        |  UInt32  |  -     |  主状态+子状态+安全状态
12-15    |  实际位置        |  Float32 |  mm    |  当前滑台位置
16-19    |  位置误差        |  Float32 |  mm    |  目标位置-实际位置
20-23    |  切割力          |  Float32 |  N     |  当前切割阻力
24-27    |  电机温度        |  Float32 |  °C    |  主轴电机温度
28       |  急停状态        |  Bool    |  -     |  急停按钮状态
29-30    |  故障代码        |  UInt16  |  -     |  当前故障编码
31       |  序列号          |  UInt8   |  -     |  数据包序列号
```

#### 设备状态位域定义 (32位)
```
位域      |  状态名称        |  编码     |  说明
----------|-----------------|----------|------------------
0-7       |  主状态          |  0-255   |  0:空闲 1:定位 2:切割 3:故障
8-15      |  子状态          |  0-255   |  详细运行状态
16-23     |  安全状态        |  0-255   |  安全系统状态位
24-31     |  扩展状态        |  0-255   |  保留扩展位
```

#### 主状态编码
- `0x00`: IDLE - 设备空闲，等待指令
- `0x01`: POSITIONING - 滑台定位移动中
- `0x02`: CUTTING - 执行切割动作中
- `0x03`: FAULT - 设备故障状态
- `0x04`: HOMING - 回零动作中
- `0x05`: CALIBRATING - 校准状态
- `0x06`: MAINTENANCE - 维护模式

### 2. 扩展状态数据 (28字节) - 低频传输 (2s)

```
字节偏移  |  数据名称        |  数据类型  |  单位  |  说明
---------|-----------------|----------|--------|------------------
0-3      |  电机电流        |  Float32 |  A     |  主轴电机电流
4-7      |  主轴转速        |  Float32 |  RPM   |  切割主轴实际转速
8-11     |  液压压力        |  Float32 |  MPa   |  夹持液压系统压力
12-15    |  刀片磨损度      |  Float32 |  %     |  刀片磨损百分比
16-19    |  振动等级        |  Float32 |  m/s²  |  设备振动幅度
20-23    |  冷却液温度      |  Float32 |  °C    |  冷却系统温度
24-27    |  功耗           |  Float32 |  kW    |  设备总功耗
```

### 3. 诊断数据 (20字节) - 按需传输

```
字节偏移  |  数据名称        |  数据类型  |  单位  |  说明
---------|-----------------|----------|--------|------------------
0-3      |  运行时间        |  UInt32  |  小时  |  设备累计运行时间
4-7      |  切割次数        |  UInt32  |  次    |  累计切割次数
8-11     |  故障次数        |  UInt32  |  次    |  累计故障次数
12-15    |  维护倒计时      |  UInt32  |  小时  |  下次维护剩余时间
16-19    |  校准偏差        |  Float32 |  mm    |  系统校准偏差值
```

---

## 通信优化机制

### 1. 分层传输策略

#### 高优先级数据 (核心状态)
- **传输频率**: 50ms (20Hz)
- **数据大小**: 32字节
- **触发条件**: 
  - 设备状态变化
  - 位置误差 > 0.01mm
  - 切割力变化 > 1N
  - 温度变化 > 0.5°C
  - 急停状态变化

#### 中优先级数据 (扩展状态)
- **传输频率**: 2s (0.5Hz)
- **数据大小**: 28字节
- **触发条件**:
  - 电流变化 > 0.1A
  - 转速变化 > 50RPM
  - 压力变化 > 0.05MPa
  - 振动变化 > 0.1m/s²

#### 低优先级数据 (诊断信息)
- **传输频率**: 按需或60s (0.017Hz)
- **数据大小**: 20字节
- **触发条件**:
  - 累计数据变化
  - 主动查询
  - 故障发生时

### 2. 变化检测算法

```python
def detect_status_change(current_data, last_data, thresholds):
    """
    检测状态数据变化
    """
    if not last_data:
        return True
    
    # 离散状态检查
    if (current_data.device_state != last_data.device_state or
        current_data.emergency_stop != last_data.emergency_stop or
        current_data.fault_code != last_data.fault_code):
        return True
    
    # 连续值变化检查
    changes = {
        'position': abs(current_data.actual_position - last_data.actual_position),
        'error': abs(current_data.position_error - last_data.position_error),
        'force': abs(current_data.cutting_force - last_data.cutting_force),
        'temp': abs(current_data.motor_temp - last_data.motor_temp)
    }
    
    return any(changes[key] > thresholds[key] for key in changes)
```

### 3. 数据压缩机制

#### 批量压缩
- **批处理大小**: 5-10个数据包
- **压缩算法**: ZLIB/GZIP
- **压缩阈值**: 数据大小 > 100字节
- **预期压缩率**: 30-50%

#### 差分编码
```python
def differential_encoding(current_data, reference_data):
    """
    差分编码 - 仅传输变化的字段
    """
    diff_data = {}
    for field in current_data:
        if current_data[field] != reference_data[field]:
            diff_data[field] = current_data[field]
    
    return diff_data
```

---

## Modbus寄存器映射

### 核心状态寄存器 (只读)
```
地址      |  功能描述        |  数据类型  |  访问权限
----------|-----------------|----------|----------
0x2000    |  时间戳(高32位)  |  UInt32  |  只读
0x2001    |  时间戳(低32位)  |  UInt32  |  只读
0x2002    |  设备状态        |  UInt32  |  只读
0x2003-04 |  实际位置        |  Float32 |  只读
0x2005-06 |  位置误差        |  Float32 |  只读
0x2007-08 |  切割力          |  Float32 |  只读
0x2009-0A |  电机温度        |  Float32 |  只读
0x200B    |  急停+故障+序列  |  UInt16  |  只读
```

### 扩展状态寄存器 (只读)
```
地址      |  功能描述        |  数据类型  |  访问权限
----------|-----------------|----------|----------
0x2010-11 |  电机电流        |  Float32 |  只读
0x2012-13 |  主轴转速        |  Float32 |  只读
0x2014-15 |  液压压力        |  Float32 |  只读
0x2016-17 |  刀片磨损度      |  Float32 |  只读
0x2018-19 |  振动等级        |  Float32 |  只读
0x201A-1B |  冷却液温度      |  Float32 |  只读
0x201C-1D |  功耗           |  Float32 |  只读
```

### 诊断数据寄存器 (只读)
```
地址      |  功能描述        |  数据类型  |  访问权限
----------|-----------------|----------|----------
0x2020-21 |  运行时间        |  UInt32  |  只读
0x2022-23 |  切割次数        |  UInt32  |  只读
0x2024-25 |  故障次数        |  UInt32  |  只读
0x2026-27 |  维护倒计时      |  UInt32  |  只读
0x2028-29 |  校准偏差        |  Float32 |  只读
```

---

## 性能优化建议

### 1. 网络优化
- **MTU设置**: 1500字节 (标准以太网)
- **TCP_NODELAY**: 启用，减少延迟
- **缓冲区大小**: 64KB发送/接收缓冲区
- **连接复用**: 保持长连接，避免频繁建立连接

### 2. 数据处理优化
- **异步处理**: 使用异步I/O处理网络通信
- **内存池**: 预分配内存块，减少GC压力
- **批量处理**: 批量读取和处理数据
- **缓存机制**: 缓存频繁访问的数据

### 3. 实时性保证
- **优先级队列**: 关键数据优先传输
- **超时机制**: 设置合理的通信超时
- **重传机制**: 关键数据包重传保证
- **心跳检测**: 定期检测连接状态

---

## 故障处理机制

### 1. 通信故障处理
```python
class CommunicationFaultHandler:
    def handle_timeout(self):
        """处理通信超时"""
        # 1. 重试连接
        # 2. 切换备用通道
        # 3. 触发告警
        
    def handle_data_corruption(self):
        """处理数据损坏"""
        # 1. 请求重传
        # 2. 使用备份数据
        # 3. 记录错误日志
```

### 2. 数据一致性保证
- **校验和**: 每个数据包包含CRC32校验
- **序列号**: 检测数据包丢失和乱序
- **时间戳**: 检测数据时效性
- **冗余传输**: 关键数据多路径传输

---

## 带宽消耗分析

### 传输量计算
```
核心状态数据:
- 32字节 × 20Hz = 640字节/秒 = 5.12Kbps

扩展状态数据:
- 28字节 × 0.5Hz = 14字节/秒 = 0.11Kbps

诊断数据:
- 20字节 × 0.017Hz = 0.34字节/秒 = 0.003Kbps

总带宽消耗: 约5.2Kbps (理论值)
实际消耗(含协议开销): 约8-10Kbps
```

### 优化效果
- **压缩优化**: 节省30-40%带宽
- **差分编码**: 在稳态下节省50-70%带宽
- **批量传输**: 减少协议开销20-30%

**优化后带宽消耗**: 约3-5Kbps

---

## 实施建议

1. **分阶段实施**
   - 第一阶段: 实现基础数据传输
   - 第二阶段: 添加压缩和优化
   - 第三阶段: 完善故障处理机制

2. **测试验证**
   - 压力测试: 验证高负载下的性能
   - 稳定性测试: 长时间运行测试
   - 故障恢复测试: 验证异常情况处理

3. **监控指标**
   - 数据传输延迟
   - 数据包丢失率
   - 压缩效率
   - 系统资源占用

通过以上优化策略，可以在保证实时性的前提下，将通信带宽消耗降低到最小，提高系统整体性能。 